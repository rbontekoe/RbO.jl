<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>2 - Building applications with Julia · RbO.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RbO.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">1 - User manual</a></li><li class="current"><a class="toctext" href>2 - Building applications with Julia</a><ul class="internal"><li><a class="toctext" href="#Building-applications-with-Julia-1">Building applications with Julia</a></li><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Tutorial-Description-1">Tutorial Description</a></li><li class="toplevel"><a class="toctext" href="#Module-A:-Creating-the-model-1">Module A: Creating the model</a></li><li><a class="toctext" href="#The-Domain-layer-1">The Domain layer</a></li><li><a class="toctext" href="#Delaring-enumerator-data-types-1">Delaring enumerator data types</a></li><li><a class="toctext" href="#Functions-for-the-API-layer-1">Functions for the API layer</a></li><li><a class="toctext" href="#Functions-for-the-Infrastructure-layer-1">Functions for the Infrastructure layer</a></li><li class="toplevel"><a class="toctext" href="#Module-B:-Implementing-the-model-1">Module B: Implementing the model</a></li><li><a class="toctext" href="#Application-structure-1">Application structure</a></li><li><a class="toctext" href="#Implementing-the-Domain-in-domain.jl-1">Implementing the Domain in domain.jl</a></li><li><a class="toctext" href="#Implementing-the-API-in-api.jl-1">Implementing the API in api.jl</a></li><li><a class="toctext" href="#Implementing-the-Infrastructure-in-infrastructure.jl-1">Implementing the Infrastructure in infrastructure.jl</a></li><li class="toplevel"><a class="toctext" href="#Module-C:-Creating-the-Module-RbO-1">Module C: Creating the Module RbO</a></li><li><a class="toctext" href="#Package-structure-1">Package structure</a></li><li><a class="toctext" href="#Defining-the-Module-1">Defining the Module</a></li><li><a class="toctext" href="#Testing-locally-1">Testing locally</a></li><li><a class="toctext" href="#Make-the-package-available-for-your-users-1">Make the package available for your users</a></li><li class="toplevel"><a class="toctext" href="#Installing-Julia-(and-Atom-and-IJulia-Notebook)-1">Installing Julia (and Atom and IJulia Notebook)</a></li><li><a class="toctext" href="#Installing-Julia-1.1.1-on-Ubuntu-18.04.3-and-1">Installing Julia 1.1.1 on Ubuntu 18.04.3 and</a></li><li><a class="toctext" href="#Working-with-Atom-1">Working with Atom</a></li><li><a class="toctext" href="#Working-with-the-Julia-Package-Manager-1">Working with the Julia Package Manager</a></li></ul></li><li><a class="toctext" href="../course2/">3 - Using Julia over the network</a></li><li><a class="toctext" href="../course3/">4 - Dockerize Julia</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>2 - Building applications with Julia</a></li></ul><a class="edit-page" href="https://github.com/rbontekoe/RbO.jl/blob/master/docs/src/course.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>2 - Building applications with Julia</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Tutorial-1" href="#Tutorial-1">Tutorial</a></h1><h2><a class="nav-anchor" id="Building-applications-with-Julia-1" href="#Building-applications-with-Julia-1">Building applications with Julia</a></h2><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p>I switched to Julia because it is easy to use, and an active community supports it. Also, I like how easy you can create documentation and help with Julia, as well as testing your application. It changed my mind when I discovered that in your documentation code fragments can automatically be tested during the creation of the document. Creating this tutorial is to check whether I can explain what I have learned from this project.</p><h2><a class="nav-anchor" id="Tutorial-Description-1" href="#Tutorial-Description-1">Tutorial Description</a></h2><h3><a class="nav-anchor" id="Target-audience-1" href="#Target-audience-1">Target audience</a></h3><p>The target audience for the tutorial <strong>Building applications with Julia</strong> is application developers who want to use Julia in a structured way.</p><h3><a class="nav-anchor" id="Summary-description-1" href="#Summary-description-1">Summary description</a></h3><p>Students will learn the technique to create a module that can to be used in container-based applications. The tutorial starts creating the domain layer. Besides the domain objects, we defined functions for the API layer and the Infrastructure layer. Students learn to create documentation for the application that also tests the code examples.</p><h3><a class="nav-anchor" id="Tutorial-format-and-duration-1" href="#Tutorial-format-and-duration-1">Tutorial format and duration</a></h3><p>tbd</p><h3><a class="nav-anchor" id="Tutorial-goals-1" href="#Tutorial-goals-1">Tutorial goals</a></h3><p>By the end of the tutorial, you should be able to:</p><ul><li>Create a model with Domain, API, and Infrastructure layers.</li><li>Create a Julia module.</li><li>Create the documentation for your module.</li><li>Let the application communicate over a network.</li></ul><h1><a class="nav-anchor" id="Module-A:-Creating-the-model-1" href="#Module-A:-Creating-the-model-1">Module A: Creating the model</a></h1><h2><a class="nav-anchor" id="The-Domain-layer-1" href="#The-Domain-layer-1">The Domain layer</a></h2><p><strong>&gt;&gt; NOTE &lt;&lt;</strong></p><p>The design is based on the <strong>Domain Driven Design and the Onion Pattern</strong>. This <a href="https://www.infoq.com/news/2014/10/ddd-onion-architecture/">link</a> explains the pattern. Accordingly, we have split the code over three scripts (under the src directory):</p><ul><li>domain.jl</li><li>api.jl</li><li>infrastructure.api</li></ul><p>You can find the code on <a href="https://github.com/rbontekoe/RbO.jl">GitHub</a>.</p><p>We have chosen a simple model. Publishers send messages to subscribers. You can think an IoT application that consists of Raspberry Pi Zeros as publishers that send room temperatures to a central system, the subscriber. In Julia, you define objects as structs.</p><pre><code class="language-none">struct Subscriber
    name
    email
end # defined Subscriber object</code></pre><p>A struct is an immutable object. So, you can&#39;t change its properties afterward. You can only read the values.</p><pre><code class="language-none"># Create a subscriber
daisy = Subscriber(&quot;Daisy&quot;, &quot;daisy@duckcity.com&quot;)

# Print the name of the subscriber to the console
println( daisy.name )

# Reassign to change the object properties.
daisy = Subscriber(&quot;Daisy Duck&quot;, &quot;daisy@duckcity.com&quot;)</code></pre><table><tr><th style="text-align: left"><em>&gt;&gt; Note &lt;&lt;</em></th></tr><tr><td style="text-align: left">When you prepend the keyword struct with &#39;mutable&#39;, you can alter its values.</td></tr></table><h2><a class="nav-anchor" id="Delaring-enumerator-data-types-1" href="#Delaring-enumerator-data-types-1">Delaring enumerator data types</a></h2><p>We could have subscribers who can do different jobs, e.g., calculate the average temperature of a data set, plotting it, or even determine trends. Because we want to define the possible values clearly, we use enumerator data types.</p><pre><code class="language-none">@enum SubscriberType begin
    MEAN_CALCULATOR
    STD_CALCULATOR
    PLOTTER
end # defined enumeration for Subscriber type</code></pre><p>We incorporate it into our Subscriber struct as follows, where we now also declare the data type of a property.  To state the data type of a variable, you append to it a pair of colons (::) followed by the name of the Type.</p><pre><code class="language-none">struct Subscriber
    name::String
    email::String
    subscribertype::SubscriberType
end # defined Subscriber object</code></pre><h2><a class="nav-anchor" id="Functions-for-the-API-layer-1" href="#Functions-for-the-API-layer-1">Functions for the API layer</a></h2><p>We make use of an API layer to make it easier for the users to work with our model. The API functions can be the best defined in the Domain layer and implemented in the API layer. We declare the next services.</p><pre><code class="language-none">function createSubscriber end
function createPublisher end
function subscribe end
function unsubscribe end
function createMessage end
function sendMessage end</code></pre><p>We implement the functions in the API layer.</p><h2><a class="nav-anchor" id="Functions-for-the-Infrastructure-layer-1" href="#Functions-for-the-Infrastructure-layer-1">Functions for the Infrastructure layer</a></h2><p>The infrastructure layer is our connection to the outer world. To be able to connect to different interfaces, we make use of the adapters. For example, to save the message, we can define adapters for in-memory storage or in a database.</p><pre><code class="language-none">function createDbConnection end
function create end
function read end
function update end
function delete end</code></pre><p>We implement the functions in the Infrastructure layer.</p><h1><a class="nav-anchor" id="Module-B:-Implementing-the-model-1" href="#Module-B:-Implementing-the-model-1">Module B: Implementing the model</a></h1><h2><a class="nav-anchor" id="Application-structure-1" href="#Application-structure-1">Application structure</a></h2><pre><code class="language-none">RbO.jl
--src
    |--api.jl
    |--domain.jl
    |--infrastructure.jl
    |--RbO.jl
--test
    |--runtests.jl</code></pre><h2><a class="nav-anchor" id="Implementing-the-Domain-in-domain.jl-1" href="#Implementing-the-Domain-in-domain.jl-1">Implementing the Domain in domain.jl</a></h2><p>We refer to <a href="https://github.com/rbontekoe/RbO.jl">github</a> for an overview of our business model. Here we show the implementation of the Subscriber, including the help documentation.</p><pre><code class="language-none">&quot;&quot;&quot;
    struct Subscriber

# Arguments
- name::String
- email::String
- subscribertype::SubscriberType

Instanstiation: see: : [`createSubscriber()`](@ref)
Reference: RbO.Subscriber

# Example
julia&gt; daisy = Subscriber(&quot;Daisy&quot;)
&quot;&quot;&quot;
struct Subscriber
    name::String
    email::String
    subscribertype::SubscriberType
    #constructors
    Subscriber( name::String ) = new( name, &quot;&quot;, MEAN_CALCULATOR )
    Subscriber( name::String, email::String ) = new( name, email, MEAN_CALCULATOR )
    Subscriber( name::String, email::String, subscribertype::SubscriberType ) = new( name, email, subscribertype )
end # defined Subscriber object</code></pre><h2><a class="nav-anchor" id="Implementing-the-API-in-api.jl-1" href="#Implementing-the-API-in-api.jl-1">Implementing the API in api.jl</a></h2><p>To make it easier for the user of our model, we offer an API. There are three ways the user can instantiate a Subscriber object. The three ways are:</p><pre><code class="language-none">createSubscriber( name::String ) ::Subscriber =
    Subscriber( name )

createSubscriber( name::String, email::String ) ::Subscriber =
    Subscriber( name, email )

createSubscriber( name::String, email::String, subscribertype::SubscriberType )::Subscriber =
    Subscriber( name, email, subscribertype )</code></pre><h2><a class="nav-anchor" id="Implementing-the-Infrastructure-in-infrastructure.jl-1" href="#Implementing-the-Infrastructure-in-infrastructure.jl-1">Implementing the Infrastructure in infrastructure.jl</a></h2><p>tbd</p><h1><a class="nav-anchor" id="Module-C:-Creating-the-Module-RbO-1" href="#Module-C:-Creating-the-Module-RbO-1">Module C: Creating the Module RbO</a></h1><p>We are in favor of documenting our code. Documenter.jl is a package to create documentation. When looking at the features of documenter.jl, we notice:</p><ul><li>Markdown language.</li><li>Uploading a module to GitHub, it adds the package automatically to your pages, e.g., rbontekoe.github.io/RbO.jl.</li><li>You can specify that documenter runs all your tests successfully before it creates the documentation, e.g., doctest(RbO) in the file make.jl.</li><li>You can determine that documenter tests the example code before it produces the manual, e.g.,  <code>jldoctest ...</code> blocks in the documentation.</li><li>You can create your developer&#39;s user manual during development.</li></ul><p>References</p><ul><li><a href="https://pkg.julialang.org/docs/julia/THl1k/1.1.1/stdlib/Markdown.html">Mark Down Language Julia</a></li><li><a href="https://juliadocs.github.io/Documenter.jl/stable/">Documenter.jl</a></li></ul><h2><a class="nav-anchor" id="Package-structure-1" href="#Package-structure-1">Package structure</a></h2><p>Your package has to have the following structure:</p><pre><code class="language-none">Package.jl
--src
    |--xxx.jl
    |--yyy.jl
    |--zzz.jl
    |--Package.jl
--test
    |--runtests.jl</code></pre><p>You should replace &#39;Package&#39; by the name you want to give the your package, e.g.,</p><pre><code class="language-none">RbO.jl
--src
    |--api.jl
    |--domain.jl
    |--infrastructure.jl
    |--RbO.jl
--test
    |--runtests.jl</code></pre><h2><a class="nav-anchor" id="Defining-the-Module-1" href="#Defining-the-Module-1">Defining the Module</a></h2><p>RbO.jl is defined as module. A module is the code between &#39;module&#39; and &#39;end&#39;.</p><pre><code class="language-none"># main module
module RbO

    export createPublisher, createSubscriber, subscribe, unsubscribe, createMessage, sendMessage

    include(&quot;api.jl&quot;)

end # end of RbO.jl
</code></pre><p>With include(&quot;api.jl&quot;) we make the API layer accessible for the module. The API Layer has access to the domain items by including it:</p><pre><code class="language-none">include(&quot;domain.jl&quot;).</code></pre><p>With &#39;export&#39; we declare which functions of the API layer are accessible by the user.</p><h2><a class="nav-anchor" id="Testing-locally-1" href="#Testing-locally-1">Testing locally</a></h2><p>During development, we want to test our code. To make our module available, we should tell Julia where it can find RbO.jl. We can define it by extending the load path:</p><pre><code class="language-none">julia&gt; push!(LOAD_PATH, &quot;/home/rob/julia_projects/RbO.jl/src/&quot;)</code></pre><h2><a class="nav-anchor" id="Make-the-package-available-for-your-users-1" href="#Make-the-package-available-for-your-users-1">Make the package available for your users</a></h2><p>You have to upload the package to GitHub to make it accessible for the user. Use the following steps.</p><ul><li>Install git.</li><li>$ sudo apt install git</li><li>Create a user account on GitHub: <a href="https://github.com/">https://github.com/</a>.</li><li>Create an empty repository, e.g., RbO.jl. See <a href="https://gist.github.com/mindplace/b4b094157d7a3be6afd2c96370d39fad">Create a repo</a>, and upload your local folder.</li></ul><p>In Julia the user can install the package as follows.</p><pre><code class="language-none">julia&gt; ]

(v1.1) pkg&gt; add https://github.com/rbontekoe/RbO.jl

(v1.1) pkg&gt; Ctrl-C

julia&gt; use RbO

julia&gt; daisy = createSubscriber(&quot;Daisy&quot;)
Subscriber(&quot;Daisy&quot;, &quot;&quot;, MEAN_CALCULATOR::SubscriberType = 0)

julia&gt; println(daisy. #Double Tab
email          name            subscribertype

julia&gt; println(daisy.name)
Daisy</code></pre><h1><a class="nav-anchor" id="Installing-Julia-(and-Atom-and-IJulia-Notebook)-1" href="#Installing-Julia-(and-Atom-and-IJulia-Notebook)-1">Installing Julia (and Atom and IJulia Notebook)</a></h1><h2><a class="nav-anchor" id="Installing-Julia-1.1.1-on-Ubuntu-18.04.3-and-1" href="#Installing-Julia-1.1.1-on-Ubuntu-18.04.3-and-1">Installing Julia 1.1.1 on Ubuntu 18.04.3 and</a></h2><p>We work with Ubuntu 18.3. Ubuntu runs on an X86 processor, in our case a Lenovo Legion Y520 on a USB disk.</p><p>The steps to install Julia. See the Packt book <a href="https://subscription.packtpub.com/book/application_development/9781788998369/1/ch01lvl1sec12/installing-julia-from-binaries">Julia 1.0 Programming</a></p><ul><li>$ sudo apt update</li><li>$ sudo apt -y install build-essential</li><li>$ mkdir testjulia</li><li>$ cd testjulia</li><li>$ wget https://julialang-s3.julialang.org/bin/linux/x64/1.1/julia-1.1.1-linux-x86_64.tar.gz</li><li>$ tar xvfz julia-1.1.1-linux-x86_64.tar.gz</li><li>$ sudo ln -s /home/rob/testjulia/julia-1.1.1/bin/julia /usr/local/bin/julia (file is located in /etc/envirionment)</li><li>$ julia</li><li>julia&gt; Ctrl-D</li></ul><p>Next, we have Atom installed as <a href="https://codeforgeek.com/install-atom-editor-ubuntu-14-04/">IDE</a></p><ul><li>$ sudo add-apt-repository ppa:webupd8team/atom</li><li>$ sudo apt update</li><li>$ sudo apt install atom</li><li>$ atom</li></ul><p>Then install the package <a href="http://docs.junolab.org/latest/man/installation/">Juno</a></p><ul><li>In Atom, go to Settings (Ctrl+,, or Cmd+, on macOS) and go to the &quot;Install&quot; panel.</li><li>Type uber-juno into the search box and hit enter. Click the install button on the package of the same name.</li><li>Atom will then set up Juno for you, installing the required Atom and Julia packages.</li></ul><p>We also installed <a href="http://docs.junolab.org/latest/man/installation/">IJulia Notebook</a></p><ul><li>$ julia</li><li>julia&gt; ] add IJulia</li><li>julia&gt; using IJulia</li><li>julia&gt; notebook()</li><li>or</li><li>julia&gt; notebook(dir=&quot;./&quot;)</li></ul><h2><a class="nav-anchor" id="Working-with-Atom-1" href="#Working-with-Atom-1">Working with Atom</a></h2><p>See also <a href="http://tutorials.jumpstartlab.com/academy/workshops/terminal_and_editor.html">Terminal and Editor</a></p><p>Suppose you want to test the file test.jl in Atom. Perform the next steps.</p><ul><li>$ mkdir julia-projects</li><li>$ cd julia-projects</li><li>$ mkdir tests</li><li>$ cd test</li><li>$ touch test.jl</li><li>$ atom</li><li>Select Open a Project and navigate to the directory &#39;julia-projects&#39;.</li><li>Select the directory &#39;test&#39; and click on OK.</li><li>Select the empty file &#39;test.jl&#39;.</li><li>Copy the example code in the section Examples - test.jl to empty file.</li><li>Before you test the code you have to import the packages RbO, Plots, and Statistics.</li><li>julia&gt; ]</li><li>(v1.1) pkg&gt; add https://github.com/rbontekoe/RbO.jl</li><li>(v1.1) pkg&gt; add Plots</li><li>(v1.1) pkg&gt; add Statistics</li><li>Ctrl-C</li><li>Now you can test the code line for line by pressing Shift-Enter.</li><li>Or go the the menu &#39;Julia&#39; and select the command &#39;Run All&#39; (or the triangle in the navigation tree).</li></ul><h2><a class="nav-anchor" id="Working-with-the-Julia-Package-Manager-1" href="#Working-with-the-Julia-Package-Manager-1">Working with the Julia Package Manager</a></h2><p><a href="https://www.simonwenkel.com/2018/10/06/a-brief-introduction-to-package-management-with-julia.html">A Brief Introduction to Package Management with Julia 1.0</a></p><p>Particularly noteworthy is the section &#39;Setting Up Projects&#39; using the package manager &#39;activate ./&#39;-command. Packages imported are only visible for the specified directory. It makes it easier to experiment with modules without creating a chaos of packages.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">1 - User manual</span></a><a class="next" href="../course2/"><span class="direction">Next</span><span class="title">3 - Using Julia over the network</span></a></footer></article></body></html>
